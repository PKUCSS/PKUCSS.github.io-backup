<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[扔玻璃杯的学问]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%89%94%E7%8E%BB%E7%92%83%E6%9D%AF%E7%9A%84%E5%AD%A6%E9%97%AE%2F</url>
    <content type="text"><![CDATA[扔玻璃杯的学问问题简述在算分研讨班上第一节课听到的有趣问题，据说是鹅厂面试题： 有一种玻璃杯质量确定但未知，需要检测。有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？ 思路暴力：​ 拿一个杯子从第一层开始往上一直扔，一定能找到答案。最坏需要99次。 ​ 似乎暴力得过头了，而且只用到一个杯子。 改进：​ 分区间扔，充分利用两个杯子。先从第10楼扔，再从第20楼扔，依次下去，如果到某一层碎掉，比如50层碎掉了，我再从41楼开始扔。这样最坏只需要19次。 目前能找到的最佳算法：继续思考刚才方法的缺陷： 当杯子质量比较差的时候，此方法还是比较快速的找到的。比如杯子是在19楼刚好碎，我只需要扔11次，比99楼刚好碎的情况要少很多次。 所以我们的愿望是：杯子的质量无论分布在哪个查找区间，都可以快速地找到。所以我想到的是可以“匀”一下刚才的方法。即 最开始我需要大胆地扔，然后再慢慢小心地扔。 具体方法设计：每次扔的区间减少一层，这样做可以保证每个区间查找的最差次数是一样的。假定第一步在15楼扔，没碎的话则下一步在29楼扔，没碎下一步在42楼扔….碎掉之后则在上一次没碎的楼层开始向上扔。那么最开始在哪一层开始扔呢？？这里我们需要拿支笔算一下：x+(x-1)+(x-2)+…+2 &gt;=100求解出答案为14。 即最终给出的解决方案是：最开始从14楼开始扔，没碎的话在27楼扔，再没碎的话在39楼扔…..一旦碎掉，则从上一次没碎的楼层逐层往上扔，即可快速确认杯子在哪一层刚好会碎掉。 这样的方法可以保证在最差的情况下也能在14次内找到楼层，平均需要的次数不到10次。 技亦灵怪矣哉，算法的trick令人惊叹。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法 面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未名湖的水动了]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%9C%AA%E5%90%8D%E6%B9%96%E7%9A%84%E6%B0%B4%E5%8A%A8%E4%BA%86%2F</url>
    <content type="text"><![CDATA[未名湖的水动了​ 湖冰初融，春寒料峭。 ​ 新学期第一次打卡未名湖，忍不住随手拍下几张不成画面的照片。不几日又是元宵，亮灯的博雅塔给人以温暖的归属感。不敢奢望充满挑战的新岁一切顺利，唯愿能长风破浪，勇往直前。 mark一下不多见的亮灯~ 愿新岁安好~]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>美景</tag>
        <tag>日常</tag>
        <tag>燕园</tag>
        <tag>未名湖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F02%2F17%2Fhello%2F</url>
    <content type="text"><![CDATA[Hello World]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
