<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flower Shots]]></title>
    <url>%2F2019%2F03%2F07%2FFlower-Shots%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>燕园</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python字典扁平化]]></title>
    <url>%2F2019%2F03%2F02%2FPython%E5%AD%97%E5%85%B8%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一道略有意思的python入门作业题，记之。 题目例如： 输入：src = {‘a’:{‘b’:1,’c’:2},’d’:{‘e’:3,’f’:{‘g’:4}}} 输出：dest = {‘a.b’:1,’a.c’:2,’d.e’:3,’d.f.g’:4} 题解涉及递归：1234567891011ans = &#123;&#125;def flatten(src,pre_key): for key in src: if type(src[key]) == dict: flatten(src[key],pre_key + key) else: ans[pre_key+key] = src[key] return flatten(&#123;'a':&#123;'b':1,'c':2&#125;,'d':&#123;'e':3,'f':&#123;'g':4&#125;&#125;&#125;,"")print(ans)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DivedeandConquer-1]]></title>
    <url>%2F2019%2F02%2F27%2FDivedeandConquer-1%2F</url>
    <content type="text"><![CDATA[Divide and Conquer求斐波那契数转化为矩阵乘法，用分治法计算，复杂度为$O(logn)$ 位乘问题设X，Y为两个n位二进制数，$n = 2^k$,求XY 传统算法$W(n) = O(n^2)$ 分治法把两个数都对半截，分解为4个子问题 X = A^{n/2}+B , Y = C^{n/2}+D\\ XY = AC2^n + (AD+BC)2^{n-2}+BD\\ W(n) = 4W(n/2) + cn \\ 由主定理 W(n) = O(n^{log4})= O(n^2)，没有本质变化，继续改进： 原本有四个子问题，AC，AD，BC，BD，通过代数变换可以减少为3个 \\ AD+BC = (A-B)（D-C)+AC+BD\\ 则W(n) =3W(n/2)+cn\\ W(n) = O(n^{log3})= O(n^{1.59})矩阵乘法A,B为两个n阶矩阵，计算C = AB 暴力算法不表，$O(n^3)$ 分治法 分解为8个子问题，仍然是$O(n^3)$ 分治法改进：Strassen算法（1969）通过简单的线性变换，将八个子问题变为七个子问题，时间复杂度： W(n) = 7W(n/2)+18(n/2)^2\\ 由主定理 W(n) = O(n^{log_2^7})= O(n^{2.8075})线性变换如下： 现代进展 Coppersmith–Winograd 算法把 N* N大小的矩阵乘法的时间复杂度降低到了：})，而2010年，Andrew Stothers再度把复杂度降低到了})，一年后的2011年，Virginia Williams把复杂度最终定格为：}) 但这些算法常数太大，实际应用较少。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[芯片测试]]></title>
    <url>%2F2019%2F02%2F27%2F%E8%8A%AF%E7%89%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[芯片测试问题描述Diogenes教授有n个被认为是完全相同的VLSI芯片，原则上它们是可以互相测试的 教授的测试装置一次可测二片，当该装置中放有两片芯片时，每一片就对另一片作测试并报告其好坏。一个好的芯片总是能够报告另一片的好坏，但一个坏的芯片的结果是不可靠的。这样，每次测试的四种可能结果如下： A报告 B报告 结论 B是好的 A是好的 AB都好或者AB都坏 B是好的 A是坏的 至少一片是坏的 B是坏的 A是好的 至少一片是坏的 B是坏的 A是坏的 至少一片是坏的 暴力方法取一块芯片，一一与其他所有芯片互相检测，假如至少有一半次数报告都是好的，则该芯片是好的。时间复杂度为$O(n^2)$ 分治法伪代码 k ← n while k &gt; 3 do ​ 将芯片分为k/2(下取整)组 ​ 对每一组 ​ if 两片好，任取一片留下 ​ else 两片同时丢掉 ​ k ← 剩下的芯片数 if k == 3 then 任取2片测试 ​ if 至少1坏，取没测的芯片 ​ else 任取1片被测芯片 if k = 2 or 1 then 任取1片 说明上述算法只是一个概要说明，对于 n为奇数的情况需要进一步处理 , 处理时间为 O(n).(剩下的那片用挑出的芯片检测) 复杂度$T(n) = T(n/2)+O(n),W(1)=0$ 由主定理，$W(n) = O(n)$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扔玻璃杯的学问]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%89%94%E7%8E%BB%E7%92%83%E6%9D%AF%E7%9A%84%E5%AD%A6%E9%97%AE%2F</url>
    <content type="text"><![CDATA[扔玻璃杯的学问问题简述在算分研讨班上第一节课听到的有趣问题，据说是鹅厂面试题： 有一种玻璃杯质量确定但未知，需要检测。有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？ 思路暴力：​ 拿一个杯子从第一层开始往上一直扔，一定能找到答案。最坏需要99次。 ​ 似乎暴力得过头了，而且只用到一个杯子。 改进：​ 分区间扔，充分利用两个杯子。先从第10楼扔，再从第20楼扔，依次下去，如果到某一层碎掉，比如50层碎掉了，我再从41楼开始扔。这样最坏只需要19次。 目前能找到的最佳算法：继续思考刚才方法的缺陷： 当杯子质量比较差的时候，此方法还是比较快速的找到的。比如杯子是在19楼刚好碎，我只需要扔11次，比99楼刚好碎的情况要少很多次。 所以我们的愿望是：杯子的质量无论分布在哪个查找区间，都可以快速地找到。所以我想到的是可以“匀”一下刚才的方法。即 最开始我需要大胆地扔，然后再慢慢小心地扔。 具体方法设计：每次扔的区间减少一层，这样做可以保证每个区间查找的最差次数是一样的。假定第一步在15楼扔，没碎的话则下一步在29楼扔，没碎下一步在42楼扔….碎掉之后则在上一次没碎的楼层开始向上扔。那么最开始在哪一层开始扔呢？？这里我们需要拿支笔算一下：x+(x-1)+(x-2)+…+2 &gt;=100求解出答案为14。 即最终给出的解决方案是：最开始从14楼开始扔，没碎的话在27楼扔，再没碎的话在39楼扔…..一旦碎掉，则从上一次没碎的楼层逐层往上扔，即可快速确认杯子在哪一层刚好会碎掉。 这样的方法可以保证在最差的情况下也能在14次内找到楼层，平均需要的次数不到10次。 技亦灵怪矣哉，算法的trick令人惊叹。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法 面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未名湖的水动了]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%9C%AA%E5%90%8D%E6%B9%96%E7%9A%84%E6%B0%B4%E5%8A%A8%E4%BA%86%2F</url>
    <content type="text"><![CDATA[未名湖的水动了​ 湖冰初融，春寒料峭。 ​ 新学期第一次打卡未名湖，忍不住随手拍下几张不成画面的照片。不几日又是元宵，亮灯的博雅塔给人以温暖的归属感。不敢奢望充满挑战的新岁一切顺利，唯愿能长风破浪，勇往直前。 mark一下不多见的亮灯~ 愿新岁安好~]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>美景</tag>
        <tag>日常</tag>
        <tag>燕园</tag>
        <tag>未名湖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F02%2F17%2Fhello%2F</url>
    <content type="text"><![CDATA[Hello World]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
