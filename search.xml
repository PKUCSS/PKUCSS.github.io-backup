<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[贪心算法的正确性证明]]></title>
    <url>%2F2019%2F03%2F15%2F%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[贪心算法的正确性证明摘要贪心算法最难的部分就是正确性的证明，常用的方法有归纳法(对算法步数归纳、对问题归纳)和交换论证法（从最优解出发，不变坏地替换，得到贪心策略的解）。下面以三个例子说明这些正确性证法。 活动选择问题——对算法步数归纳 最优装载问题——对问题规模归纳 最小延迟调度——交换论证 活动选择问题问题$S = \{ 1,2,…,n\}$为n项活动的集合，$s_i和f_i$分别为活动i的开始和结束时间，活动i与j相容当且仅当$s_i \geq f_j或s_j&gt;=f_i$,求最大的活动集 贪心策略按截止时间排序 伪代码： 正确性证明：对算法步数归纳定理：算法Select执行到第k步，选择k项活动$i_1=1,i_2,…,i_k$,那么存在最优解A包含$ i_1=1 ,i_2,…,i_k $ 只要此定理成立，算法至多到第n步得到最优解 归纳基础：设$S = \{1,2,….n\}$ 是活动集，活动按截止时间递增顺序排序，k=1，证明存在最优解包含活动1 任取最优解A，A中的活动按照截止时间递增的顺序排列，如果A的第一个活动为j，j不为1，令 A' = (A-\{j\}) ∪\{1\}由于$f_1 &lt;= f_j ，A’$ 也是最优解，而且含有1 归纳步骤： 假设命题对k为真，证明对k+1也为真 算法执行到第k步，选择了活动$i_1=1,i_2,…，i_k$ 根据归纳假设存在最优解A包含$i_1=1,i_2,…,i_k$ ,设最优解A包含$i_1=1,i_2,…，i_k $ ,A中剩下的活动选自集合$S’= \{ i | i ∈ S , s_i \geq f_k \} $ ,且$A = \{i_1,i_2,…，i_ k\} \cup B$ ,B一定是$S’$ 的最优解 根据归纳基础，存在$S’ $ 的最优解B含有$S’$ 中的第一个活动，设为$i_{k+1}$ ,且$|B’| = |B| $,于是 最优装载问题n个集装箱1,2…,n装上轮船，集装箱i的重量为$w_i$ ,轮船载重量限制为$c$ ,无体积限制。如何使装上船的集装箱最多。(假设每个集装箱重量小于c) 贪心策略将集装箱按照从轻到重排序，轻者先装 正确性证明：对规模归纳 设箱子标号按照从轻到重记为1,2,…,n n = 1 贪心选择显然得到最优解 假设对规模n-1的输入得到最优解，证明对规模n的输入也得到最优解 最小延迟调度问题任务集合S，$\forall i∈S $ ,$d_i为截止时间,t_i为加工时间，均为正整数$ 一个调度f:S→N,f(i)为任务i的开始时间。求最大延迟达到最小的调度，即求f 使得 贪心策略按照截止时间$d_i$从小到大选择任务，安排时不留空闲时间 伪代码： 正确性证明：交换论证上述算法的解的性质：没有空闲时间,没有逆序(不存在$f(i) d_j$) 命题1：所有没有逆序、没有空闲时间的调度具有相同的最大延迟 命题1证明：$f_1和f_2$都没有逆序,具有相同截止时间的任务必须被连续安排。在这些连续安排的任务中最大延迟是最后一个任务，被延迟的时间只与已安排任务加工时间之和有关，与任务标号无关。 证明思想：从一个没有空闲时间的最优解出发，在不改变最优性的条件下，转变为没有逆序的解。 如果一个最优调度存在逆序，那么存在i &lt; n使得(i,i+1构成一个逆序) 存在逆序(i,j),j = i + 1,那么交换i和j得到的解的逆序数减一，后面证明这个新的调度仍然最优 至多经过n(n-1)/2次交换得到一个没有逆序的最优调度 交换相邻逆序任务(i,j)不影响最优性： 交换i,j显然对其他任务的延迟时间没有影响 交换后不增加j的延迟 任务i在$f_2$的延迟$L_{2i}$ 小于任务j在$f_1 $ 的延迟$L_{1j}$ 因此小于$ f_1 $的最大延迟]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flower Shots]]></title>
    <url>%2F2019%2F03%2F07%2FFlower-Shots%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>燕园</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python字典扁平化]]></title>
    <url>%2F2019%2F03%2F02%2FPython%E5%AD%97%E5%85%B8%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一道略有意思的python入门作业题，记之。 题目例如： 输入：src = {‘a’:{‘b’:1,’c’:2},’d’:{‘e’:3,’f’:{‘g’:4}}} 输出：dest = {‘a.b’:1,’a.c’:2,’d.e’:3,’d.f.g’:4} 题解涉及递归：1234567891011ans = &#123;&#125;def flatten(src,pre_key): for key in src: if type(src[key]) == dict: flatten(src[key],pre_key + key) else: ans[pre_key+key] = src[key] return flatten(&#123;'a':&#123;'b':1,'c':2&#125;,'d':&#123;'e':3,'f':&#123;'g':4&#125;&#125;&#125;,"")print(ans)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DivedeandConquer-1]]></title>
    <url>%2F2019%2F02%2F27%2FDivedeandConquer-1%2F</url>
    <content type="text"><![CDATA[Divide and Conquer求斐波那契数转化为矩阵乘法，用分治法计算，复杂度为$O(logn)$ 位乘问题设X，Y为两个n位二进制数，$n = 2^k$,求XY 传统算法$W(n) = O(n^2)$ 分治法把两个数都对半截，分解为4个子问题 X = A^{n/2}+B , Y = C^{n/2}+D\\ XY = AC2^n + (AD+BC)2^{n-2}+BD\\ W(n) = 4W(n/2) + cn \\ 由主定理 W(n) = O(n^{log4})= O(n^2)，没有本质变化，继续改进： 原本有四个子问题，AC，AD，BC，BD，通过代数变换可以减少为3个 \\ AD+BC = (A-B)（D-C)+AC+BD\\ 则W(n) =3W(n/2)+cn\\ W(n) = O(n^{log3})= O(n^{1.59})矩阵乘法A,B为两个n阶矩阵，计算C = AB 暴力算法不表，$O(n^3)$ 分治法 分解为8个子问题，仍然是$O(n^3)$ 分治法改进：Strassen算法（1969）通过简单的线性变换，将八个子问题变为七个子问题，时间复杂度： W(n) = 7W(n/2)+18(n/2)^2\\ 由主定理 W(n) = O(n^{log_2^7})= O(n^{2.8075})线性变换如下： 现代进展 Coppersmith–Winograd 算法把 N* N大小的矩阵乘法的时间复杂度降低到了：})，而2010年，Andrew Stothers再度把复杂度降低到了})，一年后的2011年，Virginia Williams把复杂度最终定格为：}) 但这些算法常数太大，实际应用较少。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[芯片测试]]></title>
    <url>%2F2019%2F02%2F27%2F%E8%8A%AF%E7%89%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[芯片测试问题描述Diogenes教授有n个被认为是完全相同的VLSI芯片，原则上它们是可以互相测试的 教授的测试装置一次可测二片，当该装置中放有两片芯片时，每一片就对另一片作测试并报告其好坏。一个好的芯片总是能够报告另一片的好坏，但一个坏的芯片的结果是不可靠的。这样，每次测试的四种可能结果如下： A报告 B报告 结论 B是好的 A是好的 AB都好或者AB都坏 B是好的 A是坏的 至少一片是坏的 B是坏的 A是好的 至少一片是坏的 B是坏的 A是坏的 至少一片是坏的 暴力方法取一块芯片，一一与其他所有芯片互相检测，假如至少有一半次数报告都是好的，则该芯片是好的。时间复杂度为$O(n^2)$ 分治法伪代码 k ← n while k &gt; 3 do ​ 将芯片分为k/2(下取整)组 ​ 对每一组 ​ if 两片好，任取一片留下 ​ else 两片同时丢掉 ​ k ← 剩下的芯片数 if k == 3 then 任取2片测试 ​ if 至少1坏，取没测的芯片 ​ else 任取1片被测芯片 if k = 2 or 1 then 任取1片 说明上述算法只是一个概要说明，对于 n为奇数的情况需要进一步处理 , 处理时间为 O(n).(剩下的那片用挑出的芯片检测) 复杂度$T(n) = T(n/2)+O(n),W(1)=0$ 由主定理，$W(n) = O(n)$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扔玻璃杯的学问]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%89%94%E7%8E%BB%E7%92%83%E6%9D%AF%E7%9A%84%E5%AD%A6%E9%97%AE%2F</url>
    <content type="text"><![CDATA[扔玻璃杯的学问问题简述在算分研讨班上第一节课听到的有趣问题，据说是鹅厂面试题： 有一种玻璃杯质量确定但未知，需要检测。有一栋100层的大楼，该种玻璃杯从某一层楼扔下，刚好会碎。现给你两个杯子，问怎样检测出这个杯子的质量，即找到在哪一层楼刚好会碎？ 思路暴力：​ 拿一个杯子从第一层开始往上一直扔，一定能找到答案。最坏需要99次。 ​ 似乎暴力得过头了，而且只用到一个杯子。 改进：​ 分区间扔，充分利用两个杯子。先从第10楼扔，再从第20楼扔，依次下去，如果到某一层碎掉，比如50层碎掉了，我再从41楼开始扔。这样最坏只需要19次。 目前能找到的最佳算法：继续思考刚才方法的缺陷： 当杯子质量比较差的时候，此方法还是比较快速的找到的。比如杯子是在19楼刚好碎，我只需要扔11次，比99楼刚好碎的情况要少很多次。 所以我们的愿望是：杯子的质量无论分布在哪个查找区间，都可以快速地找到。所以我想到的是可以“匀”一下刚才的方法。即 最开始我需要大胆地扔，然后再慢慢小心地扔。 具体方法设计：每次扔的区间减少一层，这样做可以保证每个区间查找的最差次数是一样的。假定第一步在15楼扔，没碎的话则下一步在29楼扔，没碎下一步在42楼扔….碎掉之后则在上一次没碎的楼层开始向上扔。那么最开始在哪一层开始扔呢？？这里我们需要拿支笔算一下：x+(x-1)+(x-2)+…+2 &gt;=100求解出答案为14。 即最终给出的解决方案是：最开始从14楼开始扔，没碎的话在27楼扔，再没碎的话在39楼扔…..一旦碎掉，则从上一次没碎的楼层逐层往上扔，即可快速确认杯子在哪一层刚好会碎掉。 这样的方法可以保证在最差的情况下也能在14次内找到楼层，平均需要的次数不到10次。 技亦灵怪矣哉，算法的trick令人惊叹。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法 面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未名湖的水动了]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%9C%AA%E5%90%8D%E6%B9%96%E7%9A%84%E6%B0%B4%E5%8A%A8%E4%BA%86%2F</url>
    <content type="text"><![CDATA[未名湖的水动了​ 湖冰初融，春寒料峭。 ​ 新学期第一次打卡未名湖，忍不住随手拍下几张不成画面的照片。不几日又是元宵，亮灯的博雅塔给人以温暖的归属感。不敢奢望充满挑战的新岁一切顺利，唯愿能长风破浪，勇往直前。 mark一下不多见的亮灯~ 愿新岁安好~]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>美景</tag>
        <tag>日常</tag>
        <tag>燕园</tag>
        <tag>未名湖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F02%2F17%2Fhello%2F</url>
    <content type="text"><![CDATA[Hello World]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
